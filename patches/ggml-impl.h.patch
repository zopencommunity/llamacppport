diff --git a/ggml/src/ggml-impl.h b/ggml/src/ggml-impl.h
index a2e30994..d7500273 100644
--- a/ggml/src/ggml-impl.h
+++ b/ggml/src/ggml-impl.h
@@ -28,6 +28,18 @@
 #include <immintrin.h>
 #endif
 
+#if defined(__gnu_linux__)
+#include <byteswap.h>
+#elif defined(__MVS__)
+#define bswap_16(x) __builtin_bswap16(x)
+#define bswap_32(x) __builtin_bswap32(x)
+#define bswap_64(x) __builtin_bswap64(x)
+#else
+#define bswap_16(x) (x)
+#define bswap_32(x) (x)
+#define bswap_64(x) (x)
+#endif // defined(__gnu_linux__)
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -484,6 +496,18 @@ static inline ggml_bf16_t ggml_compute_fp32_to_bf16(float s) {
 #define GGML_FP32_TO_BF16(x) ggml_compute_fp32_to_bf16(x)
 #define GGML_BF16_TO_FP32(x) ggml_compute_bf16_to_fp32(x)
 
+static inline void ggml_bswap16(void * value) {
+	*((uint16_t*)value) = bswap_16(*((uint16_t*)value));
+}
+
+static inline void ggml_bswap32(void * value) {
+	*((uint32_t*)value) = bswap_32(*((uint32_t*)value));
+}
+
+static inline void ggml_bswap64(void * value) {
+	*((uint64_t*)value) = bswap_64(*((uint64_t*)value));
+}
+
 // return true if the node's results are only used by N other nodes
 // and can be fused into their calculations.
 static inline bool ggml_node_has_n_uses(const struct ggml_cgraph * cgraph, int node_idx, int32_t n_uses) {
@@ -548,6 +572,31 @@ static inline bool ggml_can_fuse(const struct ggml_cgraph * cgraph, int node_idx
 #ifdef __cplusplus
 #include <initializer_list>
 #include <vector>
+#include <type_traits>
+
+template <typename T, std::enable_if_t<sizeof(T) == 1, int> = 0>
+static inline void ggml_bswap(T * value)
+{
+    GGML_UNUSED(value);
+}
+
+template <typename T, std::enable_if_t<sizeof(T) == 2, int> = 0>
+static inline void ggml_bswap(T * value)
+{
+    ggml_bswap16(value);
+}
+
+template <typename T, std::enable_if_t<sizeof(T) == 4, int> = 0>
+static inline void ggml_bswap(T * value)
+{
+    ggml_bswap32(value);
+}
+
+template <typename T, std::enable_if_t<sizeof(T) == 8, int> = 0>
+static inline void ggml_bswap(T * value)
+{
+    ggml_bswap64(value);
+}
 
 // nicer C++ syntax for ggml_can_fuse
 inline bool ggml_can_fuse(const struct ggml_cgraph * cgraph, int node_idx, std::initializer_list<enum ggml_op> ops) {
