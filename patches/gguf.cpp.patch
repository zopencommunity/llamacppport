diff --git a/ggml/src/gguf.cpp b/ggml/src/gguf.cpp
index 53504399..e71bd790 100644
--- a/ggml/src/gguf.cpp
+++ b/ggml/src/gguf.cpp
@@ -214,16 +214,22 @@ struct gguf_context {
     size_t size      = 0; // size of `data` in bytes
 
     void * data = nullptr;
+    bool needs_byteswap = false; //only for reading, writing in non-native endianness is not supported
 };
 
 struct gguf_reader {
     FILE * file;
+    bool do_byteswap = false;
 
     gguf_reader(FILE * file) : file(file) {}
 
     template <typename T>
     bool read(T & dst) const {
-        return fread(&dst, 1, sizeof(dst), file) == sizeof(dst);
+	auto res = fread(&dst, 1, sizeof(dst), file);
+     	if (do_byteswap) {
+	   ggml_bswap(&dst);
+	}	
+        return res == sizeof(dst);
     }
 
     template <typename T>
@@ -278,7 +284,13 @@ struct gguf_reader {
             return false;
         }
         dst.resize(size);
-        return fread(dst.data(), 1, dst.length(), file) == dst.length();
+        // return fread(dst.data(), 1, dst.length(), file) == dst.length();
+	std::vector<char> temp(size);
+	if (fread(temp.data(), 1, size, file) != size) {
+	   return false;
+	}
+	dst.assign(temp.begin(), temp.end());
+	return true;
     }
 
     bool read(void * dst, const size_t size) const {
@@ -317,7 +329,7 @@ bool gguf_read_emplace_helper(const struct gguf_reader & gr, std::vector<struct
 }
 
 struct gguf_context * gguf_init_from_file_impl(FILE * file, struct gguf_init_params params) {
-    const struct gguf_reader gr(file);
+    struct gguf_reader gr(file);
     struct gguf_context * ctx = new gguf_context;
 
     bool ok = true;
@@ -351,6 +363,16 @@ struct gguf_context * gguf_init_from_file_impl(FILE * file, struct gguf_init_par
     int64_t n_tensors = 0;
 
     if (ok && gr.read(ctx->version)) {
+	uint32_t original_version = ctx->version;
+
+	if ((params.allow_byteswapping) && ((ctx->version & 0x0000FFFF) == 0) && ((ctx->version & 0xFFFF0000) != 0)) {
+	    // most likely different endianness, do byteswapping
+	    gr.do_byteswap = true;
+	    ctx->needs_byteswap = true;
+	    ggml_bswap(&(ctx->version));
+	    GGML_LOG_INFO("%s: Entered byteswapping, corrected version from %" PRIu32 "to new GGUF file version %" PRIu32 "\n", __func__, original_version, ctx->version);
+	}
+
         if (ok && ctx->version == 0) {
             GGML_LOG_ERROR("%s: bad GGUF version: %" PRIu32 "\n", __func__, ctx->version);
             ok = false;
@@ -363,7 +385,7 @@ struct gguf_context * gguf_init_from_file_impl(FILE * file, struct gguf_init_par
          * the last 4 hexadecimal digits to check if the model is the same
          * endianness as the host system.
         */
-        if (ok && (ctx->version & 0x0000FFFF) == 0x00000000) {
+        if (ok && !ctx->needs_byteswap && (ctx->version & 0x0000FFFF) == 0x00000000) {
             GGML_LOG_ERROR("%s: failed to load model: this GGUF file version %" PRIu32 " is extremely large, is there a mismatch between the host and model endianness?\n", __func__, ctx->version);
             ok = false;
         }
@@ -1356,3 +1378,7 @@ void gguf_get_meta_data(const struct gguf_context * ctx, void * data) {
     gguf_write_to_buf(ctx, buf, /*only_meta =*/ true);
     memcpy(data, buf.data(), buf.size());
 }
+
+bool gguf_needs_byteswap(const struct gguf_context * ctx) {
+    return ctx->needs_byteswap;
+}
